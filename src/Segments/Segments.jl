### This file contains public API ###

"""
    Segments(type = Float64)

Generate an empty point cloud.
By default a `Segments` object will only accept coordinates in double floating
precision (`Float64`) but a lower precision can be generated by specifying the
corresponding data type as in `Segments(Float32)`.

# Arguments
- `type`: The floating-point precision type for the point cloud (default is `Float64`).

# Returns
A `Segments` object with no vertices.

# Example
```jldoctest
julia> c = Segments();

julia> nvertices(c);

julia> nsegments(c);

julia> Segments(Float32);
```
"""
function Segments(::Type{FT} = Float64) where {FT<:AbstractFloat}
    Geom(Val(2), FT)
end

"""
    Segments(ns, type)

Generate a collection of segments with enough memory allocated to store `ns` segments. The
behaviour is equivalent to generating an empty segment collection but may be computationally more
efficient when appending a large number of segments. If a lower floating precision is
required, this may be specified as an optional second argument as in `Segments(10, Float32)`.

# Arguments
- `ns`: The number of segments to allocate memory for.
- `type`: The floating-point precision type for the segments (default is `Float64`).

# Returns
A `Segments` object with no vertices.

# Example
```jldoctest
julia> c = Points(1_000);

julia> nvertices(c);

julia> nsegments(c);

julia> Segments(1_000, Float32);
```
"""
function Segments(ns::Number, ::Type{FT} = Float64) where {FT<:AbstractFloat}
   Geom(np, Val(2), FT)
end

"""
    Segments(vertices)

Generate a collection of segments from a vector of vertices.

# Arguments
- `vertices`: List of vertices (each vertex implement as `Vec`).

# Returns
A `Segments` object.

# Example
```jldoctest
julia> verts = [Vec(0.0, 0.0, 0.0), Vec(0.0, 1.0, 0.0), Vec(0.0, 1.0, 0.0), Vec(0.0, 2.0, 0.0)];

julia> Segments(verts);
```
"""
Segments(vertices::Vector{<:Vec}) = Geom(vertices, Val(2))


"""
    Segments(segments)

Merge multiple collections of segments into a single one

# Arguments
- `segments`: Vector of segment collections to merge.

# Returns
A new `Segments` object that is the result of merging all the input segment collections.

# Example
```jldoctest
julia> s1 = Segment(length = 2.0);

julia> s2 = Segment(length = 1.0);

julia> rotatex!(s2, pi/4);

julia> s = Segments([s1,s2]);
```
"""
Segments(segments::Vector{<:Segments}) = Geom(segments)


"""
    Segment(;length = 1.0, radius = 1.0)

Create a segment with dimensions given by `length`, and `radius`. This primitive
creates a `Segments` object (i.e., geometry object with arity 2, see VPL documentation
for details). It is not compatible with `Mesh` or `Points` objects. A segment represents a
cylinder in the real world but it is stored in a much more efficient way than if we
generated an explicit triangular mesh for a cylinder. If you want to use the triangular
mesh then please `HollowCylinder()` or `SolidCylinder()` instead.

# Arguments
- `length = 1.0`: The length of the segment (distance between start and endpoint).
- `radius = 1.0`: The radius of the cylinder that the segment represents.

# Examples
```jldoctest
julia> Segment(;length = 1.0, radius = 1.0);
```
"""
function Segment(;length::FT = 1.0, radius::FT = 1.0) where FT
    trans = CT.LinearMap(CT.SDiagonal(zero(FT), zero(FT), length))
    Segment(trans, radius = radius)
end

# Create a Segment from affine transformation
function Segment(trans::CT.AbstractAffineMap; radius::FT = 1.0) where FT
    # Standard segment goes from origin to [0,0,1]
    p0 = O(FT)
    p1 = Vec(zero(FT), zero(FT), one(FT))
    # Apply transformation to each vertex and add radius as property
    s = Segments([trans(p0), trans(p1)])
    add_property(s, :radius, [1.0])
    return s
end

# Create a Segment from affine transformation and add it in-place to existing Segments object
function Segment!(segments::Segments, trans::CT.AbstractAffineMap; radius::FT = 1.0) where FT
    # Standard segment goes from origin to [0,0,1]
    p0 = O(FT)
    p1 = Vec(zero(FT), zero(FT), one(FT))
    # Apply transformation to each vertex and add radius as property
    push!(vertices(segments), trans(p0))
    push!(vertices(segments), trans(p1))
    add_property(segments, :radius, [1.0])
    return segments
end


# Types and size
"""
    nsegments(segments)

Extract the number of segments in a segment collection.

# Arguments
- `segments`: The segment collection from which to extract the number of segments.

# Returns
The number of segments in the segment collection as an integer.

# Example
```jldoctest
julia> v = [Vec(0.0, 0.0, 0.0), Vec(0.0, 1.0, 0.0), Vec(1.0, 0.0, 0.0)];

julia> c = Segments(v);

julia> nsegments(c);
```
"""
nsegments(segments::Segments) = length(segments)


# Accessor functions
"""
    get_segment(segments::Segments, i)

Retrieve the vertices of the i-th segment.

# Arguments
- `segments`: The segment collection from which to retrieve the segment.
- `i`: The index of the segment to retrieve.

# Returns
A vector containing two vertices defining the i-th segment.

# Example
```jldoctest
julia> v = [Vec(0.0, 0.0, 0.0), Vec(0.0, 1.0, 0.0), Vec(1.0, 0.0, 0.0),
            Vec(0.0, 0.0, 0.0), Vec(0.0, 1.0, 0.0), Vec(0.0, 0.0, 1.0)];

julia> c = Segments(v);

julia> get_segment(c, 3);
```
"""
get_segment(segments::Segments, i) = get_segment(vertices(segments), i)
