### This file contains public API ###

"""
    Points(type = Float64)

Generate an empty point cloud.
By default a `Points` object will only accept coordinates in double floating
precision (`Float64`) but a lower precision can be generated by specifying the
corresponding data type as in `Points(Float32)`.

# Arguments
- `type`: The floating-point precision type for the point cloud (default is `Float64`).

# Returns
A `Points` object with no vertices.

# Example
```jldoctest
julia> c = Points();

julia> nvertices(c);

julia> npoints(c);

julia> Points(Float32);
```
"""
function Points(::Type{FT} = Float64) where {FT<:AbstractFloat}
    Geom(Val(1), FT)
end

"""
    Points(np, type)

Generate a point cloud with enough memory allocated to store `np` points. The behaviour is
equivalent to generating an empty point cloud but may be computationally more efficient when
appending a large number of points. If a lower floating precision is required, this may be
specified as an optional second argument as in `Points(10, Float32)`.

# Arguments
- `np`: The number of points to allocate memory for.
- `type`: The floating-point precision type for the points (default is `Float64`).

# Returns
A `Points` object with no vertices.

# Example
```jldoctest
julia> c = Points(1_000);

julia> nvertices(c);

julia> npoints(c);

julia> Points(1_000, Float32);
```
"""
function Points(np::Number, ::Type{FT} = Float64) where {FT<:AbstractFloat}
   Geom(np, Val(1), FT)
end

"""
    Points(vertices)

Generate a point cloud from a vector of vertices.

# Arguments
- `vertices`: List of vertices (each vertex implement as `Vec`).

# Returns
A `Points` object.

# Example
```jldoctest
julia> verts = [Vec(0.0, 0.0, 0.0), Vec(0.0, 1.0, 0.0), Vec(1.0, 0.0, 0.0)];

julia> Points(verts);
```
"""
Points(vertices::Vector{<:Vec}) = Geom(vertices, Val(1))

"""
    Points(points)

Merge multiple point clouds into a single one

# Arguments
- `points`: Vector of point clouds to merge.

# Returns
A new `Points` object that is the result of merging all the input point clouds.

# Example
```jldoctest
julia> e = Ellipse(length = 2.0, width = 2.0, n = 10, mode = Points);

julia> r = Rectangle(length = 10.0, width = 0.2, mode = Points);

julia> c = Points([e,r]);
```
"""
Points(points::Vector{<:Points}) = Geom(points)



"""
    Point(;area = 1.0, normal = Vec(0.0, 0.0, 1.0))

Create a point with properties `area` and `normal`. This primitive
creates a `Points` object (i.e., geometry object with arity 1, see VPL documentation
for details). It is not compatible with `Mesh` or `Segments` objects. A point represents a
location in the real world with an associated area and orientation. Most of the time you
will not be using this function but specific primitive constructors (analogous those used
for `Mesh`).

# Arguments
- `area`: The area associated to the point.
- `normal`: The normal vector at the point (defines its orientation).

# Examples
```jldoctest
julia> Point(;area = 1.0, normal = Vec(0.0, 0.0, 1.0));
```
"""
function Point(;area::FT = 1.0, normal::Vec{FT} = Vec(0.0, 0.0, 1.0)) where {FT}
    trans = CT.LinearMap(CT.SDiagonal(zero(FT), zero(FT), zero(FT)))
    Point(trans, area = area, normal = normal)
end

# Create a Point from affine transformation and associated properties
function Point(trans::CT.AbstractAffineMap;
                 area::FT = 1.0, normal::Vec{FT} = Vec(0.0, 0.0, 1.0)) where {FT}
    # Standard point is located at the origin [0,0,1]
    p0 = O(FT)
    # Apply transformation to the point and normal
    p = Points([trans(p0)])
    norm_trans = transpose(inv(trans.linear))
    add_property!(p, :normals, [normalize(norm_trans * normal)])
    # Add other properties
    add_property!(p, :areas, [area])
    return p
end

# Create a Point from affine transformation and add it in-place to existing Points object
function Point!(points::Points, trans::CT.AbstractAffineMap;
                area::FT = 1.0, normal::Vec{FT} = Vec(0.0, 0.0, 1.0)) where {FT}
    # Standard point is located at the origin [0,0,1]
    p0 = O(FT)
    # Apply transformation to the point and normal
    push!(vertices(points), trans(p0))
    norm_trans = transpose(inv(trans.linear))
    add_property!(points, :normals, [normalize(norm_trans * normal)])
    # Add other properties
    add_property!(points, :areas, [area])
    return points
end

# Types and size
"""
    npoints(points)

Extract the number of points in a point cloud.

# Arguments
- `points`: The point cloud from which to extract the number of points.

# Returns
The number of points in the point cloud as an integer.

# Example
```jldoctest
julia> v = [Vec(0.0, 0.0, 0.0), Vec(0.0, 1.0, 0.0), Vec(1.0, 0.0, 0.0)];

julia> c = Points(v);

julia> npoints(c);
```
"""
npoints(points::Points) = length(points)


# Accessor functions
"""
    get_point(points::Points, i)

Retrieve the vertex for the i-th point in a point cloud.

# Arguments
- `points`: The point cloud from which to retrieve the point.
- `i`: The index of the point to retrieve.

# Returns
A vector containing the vertex defining the i-th point.

# Example
```jldoctest
julia> v = [Vec(0.0, 0.0, 0.0), Vec(0.0, 1.0, 0.0), Vec(1.0, 0.0, 0.0),
            Vec(0.0, 0.0, 0.0), Vec(0.0, 1.0, 0.0), Vec(0.0, 0.0, 1.0)];

julia> c = Points(v);

julia> get_point(c, 6);
```
"""
get_point(points::Points, i) = get_geom(vertices(points), i)
