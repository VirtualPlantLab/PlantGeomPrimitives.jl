### This file contains public API ###

# Common triangle mesh with duplicated vertices (no need for connectivity)
struct Mesh{VT}
    vertices::Vector{VT}
    normals::Vector{VT}
end

# Accessor functions
"""
    ntriangles(mesh)

Extract the number of triangles in a mesh.
"""
ntriangles(mesh::Mesh) = length(mesh.normals)

"""
    nvertices(mesh)

The number of vertices in a mesh.
"""
nvertices(mesh::Mesh) = length(mesh.vertices)

# Accessor functions
vertices(mesh::Mesh) = mesh.vertices
normals(mesh::Mesh) = mesh.normals
get_triangle = function(verts, i)
    i1 = (i - 1)*3 + 1
    @view verts[SVector{3,Int}(i1, i1+1, i1+2)]
end

"""
    Mesh()

Generate an empty triangular dense mesh that represents a primitive or 3D scene.
By default a `Mesh` object will only accept coordinates in double floating
precision (`Float64`) but a lower precision can be generated by specifying the
corresponding data type as in `Mesh(Float32)`.
"""
function Mesh(::Type{FT} = Float64) where {FT<:AbstractFloat}
    Mesh(Vec{FT}[], Vec{FT}[])
end

"""
    Mesh(nt, nv = nt*3)

Generate a triangular dense mesh with enough memory allocated to store `nt`
triangles and `nv` vertices. The behaviour is equivalent to generating an empty
mesh but may be computationally more efficient when appending a large number of
primitives. If a lower floating precision is required, this may be specified
as an optional third argument as in `Mesh(10, 30, Float32)`.
"""
function Mesh(nt, ::Type{FT} = Float64) where {FT<:AbstractFloat}
    nt = nv*3
    verts = Vec{FT}[]
    sizehint!(verts, nv)
    norms = Vec{FT}[]
    sizehint!(norms, nt)
    Mesh(verts, norms)
end

# Merge multiple meshes into a single one
function Mesh(meshes::Vector{Mesh{VT}}) where {VT}
    # Positions where each old mesh starts in the new mesh
    nverts = cumsum(nvertices(m) for m in meshes)
    ntriangs = cumsum(ntriangles(m) for m in meshes)
    # Allocate elements of the new mesh
    verts = Vector{VT}(undef, last(nverts))
    norms = Vector{VT}(undef, last(ntriangs))
    # Fill up the elements of the new mesh
    @inbounds for i in eachindex(meshes)
        mesh = meshes[i]
        # First mesh is simple
        if i == 1
            for v = 1:nverts[1]
                verts[v] = vertices(mesh)[v]
            end
            for f = 1:ntriangs[1]
                norms[f] = normals(mesh)[f]
            end
        # Other meshes start where previous mesh ended
        else
            v0 = nverts[i-1]
            f0 = ntriangs[i-1]
            for v = v0+1:nverts[i]
                verts[v] = vertices(mesh)[v-v0]
            end
            for f = f0+1:ntriangs[i]
                norms[f] = normals(mesh)[f-f0]
            end
        end
    end
    Mesh(verts, norms)
end

# Area of a mesh
function area_triangle(v1::Vec{FT}, v2::Vec{FT}, v3::Vec{FT}) where {FT<:AbstractFloat}
    e1 = v2 .- v1
    e2 = v3 .- v1
    FT(0.5) * norm(e1 Ã— e2)
end

"""
    area(m::Mesh)

Total surface area of a mesh (as the sum of areas of individual triangles).
"""
function area(m::Mesh)
    sum(area_triangle(get_triangle(vertices(m), i)...) for i in 1:ntriangles(m))
end

"""
    areas(m::Mesh)

A vector with the areas of the different triangles that form a mesh.
"""
areas(m::Mesh) = [area_triangle(get_triangle(vertices(m), i)...) for i in 1:ntriangles(m)]

# Facilitate testing
==(m1::Mesh, m2::Mesh) = vertices(m1) == vertices(m2) && normals(m1) == normals(m2)

function isapprox(
    m1::Mesh,
    m2::Mesh;
    atol::Real = 0.0,
    rtol::Real = atol > 0.0 ? 0.0 : sqrt(eps(1.0)),
)
    isapprox(vertices(m1), vertices(m2), atol = atol, rtol = rtol) &&
        isapprox(normals(m1), normals(m2), atol = atol, rtol = rtol)
end
